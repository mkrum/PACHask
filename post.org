
#+TITLE: PAC Learning By Example In Haskell
#+OPTIONS: toc:nil author:nil timestamp:nil 

[[https://cs.nyu.edu/~mohri/mlbook/][Link to the book]]

* Probably Approximately Correct (PAC) Learning

What can be learned? Are some things harder to learn than others? 

PAC learning is a powerful framework for thinking about machine learning and all
of these questions. It also, fun fact, is the namesake for this website. The goal of this
installment is to walk through some of the basic ideas of PAC learning by
demonstration in Haskell.

This post heavily relies on the first chapter of the book "Foundations of
Machine Learning" and notes from a series of lectures given by Leslie Valiant.

** Introduction

Machine learning can be roughly described as a process of "learning" a model from
a dataset. Let's make this a little more concrete. 

We have an input space, $\mathcal{X}$. This is the underlying type that will
use to represent our data. For example, if $\mathcal{X} = \mathbb{R}^2$, then
our input is going to be two dimensional real numbers. 

We have the output space, $\mathcal{Y}$. This could be a list of classes,
(e.g. $\mathcal{Y} = \{\text{"cat"},  \text{"dog"} \}"$), or an estimated value for
a regression problem (e.g. $\mathcal{Y} = \mathbb{R}$). For this introduction,
we will focus on binary classification problems, $\mathcal{Y} = \{ 0, 1 \}$. 

What we want to learn a function, or concept, that maps from the input space to
the output space. Mathematically, 
\begin{equation}
c: \mathcal{X} \rightarrow \mathcal{Y}
\end{equation}
In haskell, we can make a type synonym, 
#+BEGIN_SRC haskell
type Concept x y = x -> y
#+END_SRC
The concept $c$ will be part of a larger space of concepts
$\mathcal{C}$. For example, 

We will have some dataset, $S = ((x_1, y_1), \dots, (x_m, y_m))$. Each $x_i \sim
\mathcal{D}$, where $\mathcal{D}$ is some distribution. Each label will be
generated by some hidden conco


#+BEGIN_SRC haskell
labelData :: Concept x y -> [x] -> [(x, y)]                                                                                                                                                 
labelData concept dataList = map (\x -> (x, concept x)) dataList                                                                                                                            

isCorrect :: (Eq y) => Concept x y -> (x, y) -> Bool                                                                                                                                        
isCorrect c (x, y) = (c x) == y                                                                                                                                                             

isIncorrect :: (Eq y) => Concept x y -> (x, y) -> Bool                                                                                                                                      
isIncorrect = ((not .) . isCorrect)                                                                                                                                                         
#+END_SRC

#+BEGIN_SRC haskell
errorOf :: (Eq y) => Concept x y -> [(x, y)] -> Float                                                                                                                                       
errorOf c dataList =                                                                                                                                                                        
  let incorrectList = filter (\x -> isIncorrect c x) dataList                                                                                                                               
      total = (fromIntegral (length dataList))::Float                                                                                                                                       
      totalIncorrect = (fromIntegral (length incorrectList))::Float                                                                                                                         
  in totalIncorrect / total 
#+END_SRC

#+BEGIN_SRC haskell
evaluateConcepts :: (Eq y) => Concept x y -> Concept x y -> RandGen x -> RandGen Float                                                                                                      
evaluateConcepts concept hypothesis dataGen g = let                                                                                                                                         
  (testPoints, g1) = chainGenerate 10000 dataGen g                                                                                                                                          
  labeledTestPoints = labelData concept testPoints                                                                                                                                          
  in ((errorOf hypothesis labeledTestPoints), g1)  
#+END_SRC

#+BEGIN_SRC haskell
pacEvaluate :: (BoolPACConcept a x) => ([(x, Bool)] -> a) -> RandGen a -> RandGen x -> Int -> RandGen Float                                                                                  48 pacEvaluate learnFn generateConcept valGenerator numTrain g = let                                                                                                                           
  (hiddenConcept, g1) = generateConcept g                                                                                                                                                   
  (trainPoints, g2) = chainGenerate numTrain valGenerator g1                                                                                                                                
  labeledTrainPoints = labelData (apply hiddenConcept) trainPoints                                                                                                                          
  learnedConcept = learnFn labeledTrainPoints                                                                                                                                               
  in (evaluateConcepts (apply hiddenConcept) (apply learnedConcept) valGenerator g2) 
#+END_SRC

#+BEGIN_SRC haskell
estimateDelta:: Int -> Float -> RandGen Float -> StdGen -> Float                                                                                                                            
estimateDelta n epsilon evalFn g = let                                                                                                                                                      
  (results, g1) = chainGenerate n evalFn g                                                                                                                                                  
  successes = filter (<= epsilon) results                                                                                                                                                   
  in fromIntegral (length successes) / (fromIntegral n)  
#+END_SRC

#+BEGIN_SRC haskell
data Interval = Interval { lower::Float, upper::Float }                                                                                                                                      62                                                                                                                                                                                             

isInInterval :: Interval -> Float -> Bool                                                                                                                                                   
isInInterval (Interval lower upper) val = (val >= lower) && (val <= upper) 
#+END_SRC

#+BEGIN_SRC haskell
instance BoolPACConcept Interval Float where                                                                                                                                                
                                                                                                                                                                                            
  apply = isInInterval                                                                                                                                                                      
                                                                                                                                                                                            
  learn dataList =                                                                                                                                                                          
        let positive_examples = filter (\x -> snd x) dataList                                                                                                                               
            positive_points = map (\x -> fst x) positive_examples                                                                                                                           
        in if (leng 77 randomInterval :: RandGen Interval                                                                                                                                                          
#+END_SRC

#+BEGIN_SRC haskell
  randomInterval :: RandGen Interval
  randomInterval g =                                                                                                                                                                          
      let (valOne, g1) = random g                                                                                                                                                             
	  (valTwo, g2) = random g1                                                                                                                                                            
     in if valOne < valTwo                                                                                                                                                                    
	then (Interval valOne valTwo, g2)                                                                                                                                                     
	else (Interval valTwo valOne, g2) th positive_points) > 0                                                                                                                                                  
	  then Interval (minimum positive_points) (maximum positive_points)                                                                                                               
	  else Interval (fst (dataList !! 0)) (fst (dataList !! 0)) 
#+END_SRC











